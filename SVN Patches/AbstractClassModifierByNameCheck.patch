Index: src/testinputs/com/puppycrawl/tools/checkstyle/naming/InputAbstractClassName.java
===================================================================
--- src/testinputs/com/puppycrawl/tools/checkstyle/naming/InputAbstractClassName.java	(revision 2535)
+++ src/testinputs/com/puppycrawl/tools/checkstyle/naming/InputAbstractClassName.java	(working copy)
@@ -2,7 +2,7 @@
 
 abstract public class InputAbstractClassName {
 }
-
+// abstract --> ^Abstract.*$|^.*Factory$
 abstract class NonAbstractClassName {
 }
 
@@ -21,3 +21,20 @@
 
 class NonAbstractClass {
 }
+
+//^Abstract.*$|^.*Factory$ --> abstract
+class AbstractClass {
+}
+
+class Class1Factory {
+}
+
+abstract class AbstractClassName2 {
+    class AbstractInnerClass {
+    }
+}
+
+abstract class Class2Factory {
+    class WellNamedFactory {
+    }
+}
Index: src/tests/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheckTest.java
===================================================================
--- src/tests/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheckTest.java	(revision 2535)
+++ src/tests/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheckTest.java	(working copy)
@@ -8,6 +8,7 @@
 public class AbstractClassNameCheckTest extends BaseCheckTestSupport
 {
     @Test
+    // abstract --> ^Abstract.*$|^.*Factory$
     public void testIllegalAbstractClassName() throws Exception
     {
         final DefaultConfiguration checkConfig =
@@ -18,6 +19,42 @@
             "9:1: Name 'FactoryWithBadName' must match pattern '^Abstract.*$|^.*Factory$'.",
             "13:5: Name 'NonAbstractInnerClass' must match pattern '^Abstract.*$|^.*Factory$'.",
         };
+        checkConfig.addAttribute("checkName", "true");
+        checkConfig.addAttribute("checkModifier", "false");
         verify(checkConfig, getPath("naming" + File.separator + "InputAbstractClassName.java"), expected);
     }
+
+    @Test
+    // ^Abstract.*$|^.*Factory$ --> abstract
+	public void testIllegalClassType() throws Exception {
+		final DefaultConfiguration checkConfig = createCheckConfig(AbstractClassNameCheck.class);
+        final String[] expected = {
+                "26:1: Class 'AbstractClass' must has abstract modifier.",
+                "29:1: Class 'Class1Factory' must has abstract modifier.",
+                "33:5: Class 'AbstractInnerClass' must has abstract modifier.",
+                "38:5: Class 'WellNamedFactory' must has abstract modifier.",
+                };
+        checkConfig.addAttribute("checkName", "false");
+        checkConfig.addAttribute("checkModifier", "true");
+		verify(checkConfig, getPath("naming" + File.separator + "InputAbstractClassName.java"), expected);
+    }
+
+    @Test
+    //all variants
+    public void testAllVariants() throws Exception {
+        final DefaultConfiguration checkConfig = createCheckConfig(AbstractClassNameCheck.class);
+        final String[] expected = {
+                "3:1: Name 'InputAbstractClassName' must match pattern '^Abstract.*$|^.*Factory$'.",
+                "6:1: Name 'NonAbstractClassName' must match pattern '^Abstract.*$|^.*Factory$'.",
+                "9:1: Name 'FactoryWithBadName' must match pattern '^Abstract.*$|^.*Factory$'.",
+                "13:5: Name 'NonAbstractInnerClass' must match pattern '^Abstract.*$|^.*Factory$'.",
+                "26:1: Class 'AbstractClass' must has abstract modifier.",
+                "29:1: Class 'Class1Factory' must has abstract modifier.",
+                "33:5: Class 'AbstractInnerClass' must has abstract modifier.",
+                "38:5: Class 'WellNamedFactory' must has abstract modifier.",
+        };
+        checkConfig.addAttribute("checkName", "true");
+        checkConfig.addAttribute("checkModifier", "true");
+        verify(checkConfig, getPath("naming" + File.separator + "InputAbstractClassName.java"), expected);
+    }
 }
Index: src/checkstyle/com/puppycrawl/tools/checkstyle/checks/naming/messages.properties
===================================================================
--- src/checkstyle/com/puppycrawl/tools/checkstyle/checks/naming/messages.properties	(revision 2535)
+++ src/checkstyle/com/puppycrawl/tools/checkstyle/checks/naming/messages.properties	(working copy)
@@ -1,3 +1,4 @@
 name.invalidPattern=Name ''{0}'' must match pattern ''{1}''.
 illegal.abstract.class.name=Name ''{0}'' must match pattern ''{1}''.
-method.name.equals.class.name=Method Name ''{0}'' must not equal the enclosing class name.
\ No newline at end of file
+no.abstract.class.modifier=Class ''{0}'' must has abstract modifier.
+method.name.equals.class.name=Method Name ''{0}'' must not equal the enclosing class name.
Index: src/checkstyle/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java
===================================================================
--- src/checkstyle/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java	(revision 2535)
+++ src/checkstyle/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java	(working copy)
@@ -25,27 +25,54 @@
 /**
  * <p>
  * Ensures that the names of abstract classes conforming to some
- * regular expression.
+ * regular expression and check up the abstract modifier of class.
  * </p>
  * <p>
  * Rationale: Abstract classes are convenience base class
  * implementations of interfaces, not types as such. As such
- * they should be named to indicate this.
+ * they should be named to indicate this. Also if names of classes
+ * starts with 'Abstract' it's very convenient that they will
+ * have abstract modifier.
  * </p>
  *
  * @author <a href="mailto:simon@redhillconsulting.com.au">Simon Harris</a>
+ * @author <a href="mailto:solid.danil@gmail.com">Danil Lopatin</a>
  */
 public final class AbstractClassNameCheck extends AbstractFormatCheck
 {
-    /** Defualt format for abstract class names */
+    /** Default format for abstract class names */
     private static final String DEFAULT_FORMAT = "^Abstract.*$|^.*Factory$";
 
+    /** allow checking 'abstract' modifiers */
+    private boolean mCheckAbstractModifier;
+
+    /** allow checking name by abstract modifier */
+    private boolean mCheckName = true;
+
     /** Creates new instance of the check. */
     public AbstractClassNameCheck()
     {
         super(DEFAULT_FORMAT);
     }
 
+    /**
+     * Enable|Disable checking the class type.
+     * @param aValue allow check abstract modifier.
+     */
+    public void setCheckModifier(boolean aValue)
+    {
+        mCheckAbstractModifier = aValue;
+    }
+
+    /**
+     * Enable|Disable checking the class name if class has abstract modifier.
+     * @param aValue allow check class name.
+     */
+    public void setCheckName(boolean aValue)
+    {
+        mCheckName = aValue;
+    }
+
     @Override
     public int[] getDefaultTokens()
     {
@@ -76,15 +103,24 @@
      */
     private void visitClassDef(DetailAST aAST)
     {
+        final String className =
+            aAST.findFirstToken(TokenTypes.IDENT).getText();
         if (isAbstract(aAST)) {
-            final String className =
-                aAST.findFirstToken(TokenTypes.IDENT).getText();
-
-            if (!isMatchingClassName(className)) {
+            // if class has abstract modifier
+            if (mCheckName && !isMatchingClassName(className)) {
                 log(aAST.getLineNo(), aAST.getColumnNo(),
                     "illegal.abstract.class.name", className, getFormat());
             }
         }
+        else {
+            // if class without abstract modifier
+            if (mCheckAbstractModifier
+                    && isMatchingClassName(className))
+            {
+                log(aAST.getLineNo(), aAST.getColumnNo(),
+                        "no.abstract.class.modifier", className);
+            }
+        }
     }
 
     /**
